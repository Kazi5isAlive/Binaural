<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Brainwave Entrainment</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.js"></script>
  <!-- lame.js for MP3 encoding -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.0/lame.min.js"></script>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
  <div class="max-w-3xl w-full bg-white rounded-xl shadow-md p-6">
    <h2 class="text-2xl font-bold mb-2 text-center">Advanced Brainwave Entrainment</h2>
    
    <div id="errorMessage" class="hidden mb-4 p-3 bg-red-100 text-red-800 rounded-md"></div>
    
    <div class="mb-4">
      <div class="flex flex-wrap justify-center gap-1 mb-4">
        <button class="preset-btn px-3 py-2 rounded bg-indigo-600 text-white" data-type="delta">Delta (0.5-4Hz)</button>
        <button class="preset-btn px-3 py-2 rounded bg-gray-200" data-type="theta">Theta (4-8Hz)</button>
        <button class="preset-btn px-3 py-2 rounded bg-gray-200" data-type="alpha">Alpha (8-13Hz)</button>
        <button class="preset-btn px-3 py-2 rounded bg-gray-200" data-type="beta">Beta (13-30Hz)</button>
        <button class="preset-btn px-3 py-2 rounded bg-gray-200" data-type="gamma">Gamma (30-100Hz)</button>
      </div>
      
      <button id="playButton" class="w-full py-3 rounded-lg font-bold text-lg mb-4 bg-green-500 hover:bg-green-600 text-white">Start</button>
    </div>
    
    <div class="mb-2 border-b pb-2">
      <h3 class="font-medium mb-2">Basic Settings</h3>
      <div class="flex items-center space-x-2 mb-4">
        <button id="binauralToggle" class="px-4 py-2 rounded-md flex-1 bg-indigo-600 text-white">Binaural Beats: ON</button>
        <button id="noiseToggle" class="px-4 py-2 rounded-md flex-1 bg-indigo-600 text-white">White Noise: ON</button>
      </div>
      
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div><label class="block text-sm font-medium mb-1">Base Frequency: <span id="baseFreqValue">300</span> Hz</label><input id="baseFreq" type="range" min="100" max="800" step="10" value="300" class="w-full"/></div>
        <div><label class="block text-sm font-medium mb-1">Beat Frequency: <span id="beatFreqValue">5</span> Hz</label><input id="beatFreq" type="range" min="0.5" max="40" step="0.5" value="5" class="w-full"/></div>
        <div><label class="block text-sm font-medium mb-1">Volume: <span id="mainVolumeValue">50</span>%</label><input id="mainVolume" type="range" min="0" max="1" step="0.01" value="0.5" class="w-full"/></div>
        <div><label class="block text-sm font-medium mb-1">Noise Volume: <span id="noiseVolumeValue">15</span>%</label><input id="noiseVolume" type="range" min="0" max="0.5" step="0.01" value="0.15" class="w-full"/></div>
        <div><label class="block text-sm font-medium mb-1">Noise Frequency: <span id="noiseFreqValue">9500</span> Hz</label><input id="noiseFreq" type="range" min="1000" max="20000" step="100" value="9500" class="w-full"/></div>
      </div>
    </div>
    
    <button id="advancedToggle" class="mb-4 px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-md flex items-center justify-center w-full">Show Advanced Options</button>
    
    <div id="advancedPanel" class="hidden space-y-4">
      <div class="p-3 bg-gray-50 rounded-md">
        <div class="flex items-center mb-2"><input type="checkbox" id="isochronicToggle" class="mr-2 h-4 w-4"/><label for="isochronicToggle" class="font-medium">Isochronic Tones</label></div>
        <div class="pl-6"><label class="block text-sm mb-1">Pulse Rate: <span id="isochronicRateValue">5</span> Hz</label><input id="isochronicRate" type="range" min="0.5" max="20" step="0.5" value="5" class="w-full"/><p class="text-xs text-gray-500 mt-1">Creates rhythmic on/off pulses that can help entrain brainwaves</p></div>
      </div>
      
      <div class="p-3 bg-gray-50 rounded-md">
        <div class="flex items-center mb-2"><input type="checkbox" id="sweepToggle" class="mr-2 h-4 w-4"/><label for="sweepToggle" class="font-medium">Frequency Sweep</label></div>
        <div class="pl-6 grid grid-cols-2 gap-2">
          <div><label class="block text-sm mb-1">Min: <span id="sweepMinValue">2</span> Hz</label><input id="sweepMin" type="range" min="0.5" max="7.5" step="0.5" value="2" class="w-full"/></div>
          <div><label class="block text-sm mb-1">Max: <span id="sweepMaxValue">8</span> Hz</label><input id="sweepMax" type="range" min="2.5" max="40" step="0.5" value="8" class="w-full"/></div>
          <p class="text-xs text-gray-500 mt-1 col-span-2">Gradually changes frequencies to guide brainwaves through different states</p>
        </div>
      </div>
      
      <div class="p-3 bg-gray-50 rounded-md">
        <div class="flex items-center mb-2"><input type="checkbox" id="dualToggle" class="mr-2 h-4 w-4"/><label for="dualToggle" class="font-medium">Dual Binaural Beats</label></div>
        <div class="pl-6"><label class="block text-sm mb-1">Secondary Beat: <span id="secondaryBeatFreqValue">8</span> Hz</label><input id="secondaryBeatFreq" type="range" min="0.5" max="40" step="0.5" value="8" class="w-full"/><p class="text-xs text-gray-500 mt-1">Adds a second binaural beat at a different frequency for complex interference patterns</p></div>
      </div>
      
      <div class="p-3 bg-gray-50 rounded-md"><div class="flex items-center"><input type="checkbox" id="monauralToggle" class="mr-2 h-4 w-4"/><label for="monauralToggle" class="font-medium">Monaural Beats</label></div><p class="text-xs text-gray-500 mt-1 pl-6">Adds pre-mixed beats that don't require stereo separation and may produce stronger entrainment</p></div>
      
      <div class="p-3 bg-gray-50 rounded-md"><div class="flex items-center"><input type="checkbox" id="harmonicsToggle" class="mr-2 h-4 w-4"/><label for="harmonicsToggle" class="font-medium">Harmonic Layering</label></div><p class="text-xs text-gray-500 mt-1 pl-6">Adds harmonic overtones that may enhance neural response and create a richer sound</p></div>
    </div>
    
    <div class="mt-6 p-4 border rounded-lg bg-gray-50">
      <h3 class="font-bold text-lg mb-3">Export Session</h3>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
        <div><label class="block text-sm font-medium mb-1">Duration (minutes)</label><select id="exportDuration" class="w-full p-2 border rounded"><option value="5">5 minutes</option><option value="10" selected>10 minutes</option><option value="20">20 minutes</option><option value="30">30 minutes</option><option value="45">45 minutes</option><option value="60">60 minutes</option></select></div>
        <div><label class="block text-sm font-medium mb-1">Filename</label><input type="text" id="exportFilename" class="w-full p-2 border rounded" placeholder="brainwave-session" value="brainwave-session"/></div>
      </div>
      <div id="exportProgress" class="hidden mb-3"><div class="h-2 bg-gray-200 rounded overflow-hidden"><div id="progressBar" class="h-full bg-green-500 transition-all duration-300" style="width: 0%"></div></div><p id="progressText" class="text-sm text-center mt-1">Generating MP3... 0%</p></div>
      <button id="exportButton" class="w-full py-2 rounded font-medium bg-blue-600 hover:bg-blue-700 text-white">Export 10-minute MP3</button>
      <p class="text-xs text-gray-500 mt-2">The export process may take some time depending on your device's performance and the selected duration.</p>
    </div>
    
    <div class="mt-4 text-sm text-gray-600">
      <p class="mb-1"><strong>Current configuration:</strong></p>
      <ul class="list-disc pl-5" id="configList">
        <li>Left ear: 300 Hz</li>
        <li>Right ear: 305 Hz</li>
        <li>Binaural beat: 5 Hz (theta)</li>
        <li>Background noise: 9500 Hz, Q: 0.5</li>
      </ul>
      <p class="mt-2 text-center text-xs italic">For best results, use stereo headphones</p>
    </div>
  </div>

  <script>
    let audioContext = null;
    let leftOscillator = null;
    let rightOscillator = null;
    let secondaryLeft = null;
    let secondaryRight = null;
    let noiseNode = null;
    let noiseFilter = null;
    let noiseGain = null;
    let mainGain = null;
    let isochronicGain = null;
    let isochronicInterval = null;
    let sweepInterval = null;

    let isPlaying = false;
    let baseFreq = 300;
    let beatFreq = 5;
    let mainVolume = 0.5;
    let brainwaveType = 'delta';
    let binauralEnabled = true;
    let noiseEnabled = true;
    let noiseVolume = 0.15;
    let noiseFreq = 9500;
    let noiseQ = 0.5;
    let noiseSweepEnabled = false;
    let noiseMinFreq = 6000;
    let noiseMaxFreq = 12000;
    let isochronicEnabled = false;
    let isochronicRate = 5;
    let sweepEnabled = false;
    let sweepMin = 2;
    let sweepMax = 8;
    let dualEnabled = false;
    let secondaryBeatFreq = 8;
    let monauralEnabled = false;
    let harmonicsEnabled = false;
    let isExporting = false;
    let exportDuration = 10;
    let exportFilename = 'brainwave-session';

    const playButton = document.getElementById('playButton');
    const advancedToggle = document.getElementById('advancedToggle');
    const advancedPanel = document.getElementById('advancedPanel');
    const exportButton = document.getElementById('exportButton');
    const binauralToggleBtn = document.getElementById('binauralToggle');
    const noiseToggleBtn = document.getElementById('noiseToggle');
    const errorMessageEl = document.getElementById('errorMessage');
    const exportProgressEl = document.getElementById('exportProgress');
    const progressBarEl = document.getElementById('progressBar');
    const progressTextEl = document.getElementById('progressText');
    const configListEl = document.getElementById('configList');

    function init() {
      playButton.addEventListener('click', togglePlay);
      advancedToggle.addEventListener('click', toggleAdvancedPanel);
      exportButton.addEventListener('click', handleExport);
      document.querySelectorAll('.preset-btn').forEach(btn => btn.addEventListener('click', () => setBrainwavePreset(btn.dataset.type)));
      binauralToggleBtn.addEventListener('click', toggleBinaural);
      noiseToggleBtn.addEventListener('click', toggleNoise);
      setupInputHandlers();
      updateUI();
    }

    function setupInputHandlers() {
      document.getElementById('baseFreq').addEventListener('input', e => { baseFreq = Number(e.target.value); document.getElementById('baseFreqValue').textContent = baseFreq; if (isPlaying && leftOscillator && rightOscillator) { leftOscillator.frequency.value = baseFreq; rightOscillator.frequency.value = baseFreq + beatFreq; } updateConfigList(); });
      document.getElementById('beatFreq').addEventListener('input', e => { beatFreq = Number(e.target.value); document.getElementById('beatFreqValue').textContent = beatFreq; if (isPlaying && rightOscillator) { rightOscillator.frequency.value = baseFreq + beatFreq; } updateConfigList(); });
      document.getElementById('mainVolume').addEventListener('input', e => { mainVolume = Number(e.target.value); document.getElementById('mainVolumeValue').textContent = Math.round(mainVolume * 100); if (mainGain) { mainGain.gain.value = mainVolume; } });
      document.getElementById('noiseVolume').addEventListener('input', e => { noiseVolume = Number(e.target.value); document.getElementById('noiseVolumeValue').textContent = Math.round(noiseVolume * 100); if (noiseGain) { noiseGain.gain.value = noiseVolume; } });
      document.getElementById('noiseFreq').addEventListener('input', e => { noiseFreq = Number(e.target.value); document.getElementById('noiseFreqValue').textContent = noiseFreq; if (noiseFilter) { noiseFilter.frequency.value = noiseFreq; } updateConfigList(); });
      document.getElementById('isochronicToggle').addEventListener('change', e => { isochronicEnabled = e.target.checked; if (isPlaying) { if (isochronicEnabled) startIsochronicPulses(); else stopIsochronicPulses(); } updateConfigList(); });
      document.getElementById('isochronicRate').addEventListener('input', e => { isochronicRate = Number(e.target.value); document.getElementById('isochronicRateValue').textContent = isochronicRate; if (isPlaying && isochronicEnabled) { stopIsochronicPulses(); startIsochronicPulses(); } updateConfigList(); });
      document.getElementById('sweepToggle').addEventListener('change', e => { sweepEnabled = e.target.checked; if (isPlaying) { if (sweepEnabled) startFrequencySweep(); else if (sweepInterval) { clearInterval(sweepInterval); sweepInterval = null; rightOscillator.frequency.value = baseFreq + beatFreq; } } document.getElementById('baseFreq').disabled = sweepEnabled && isPlaying; document.getElementById('beatFreq').disabled = sweepEnabled && isPlaying; updateConfigList(); });
      document.getElementById('sweepMin').addEventListener('input', e => { sweepMin = Number(e.target.value); document.getElementById('sweepMinValue').textContent = sweepMin; document.getElementById('sweepMax').min = sweepMin + 0.5; updateConfigList(); });
      document.getElementById('sweepMax').addEventListener('input', e => { sweepMax = Number(e.target.value); document.getElementById('sweepMaxValue').textContent = sweepMax; document.getElementById('sweepMin').max = sweepMax - 0.5; updateConfigList(); });
      document.getElementById('dualToggle').addEventListener('change', e => { dualEnabled = e.target.checked; updateConfigList(); });
      document.getElementById('secondaryBeatFreq').addEventListener('input', e => { secondaryBeatFreq = Number(e.target.value); document.getElementById('secondaryBeatFreqValue').textContent = secondaryBeatFreq; if (isPlaying && dualEnabled && secondaryRight) { secondaryRight.frequency.value = baseFreq * 1.5 + secondaryBeatFreq; } updateConfigList(); });
      document.getElementById('monauralToggle').addEventListener('change', e => { monauralEnabled = e.target.checked; updateConfigList(); });
      document.getElementById('harmonicsToggle').addEventListener('change', e => { harmonicsEnabled = e.target.checked; updateConfigList(); });
      document.getElementById('exportDuration').addEventListener('change', e => { exportDuration = Number(e.target.value); exportButton.textContent = `Export ${exportDuration}-minute MP3`; });
      document.getElementById('exportFilename').addEventListener('input', e => { exportFilename = e.target.value; });
    }

    function toggleBinaural() { binauralEnabled = !binauralEnabled; updateUI(); }
    function toggleNoise() { noiseEnabled = !noiseEnabled; updateUI(); }

    function updateUI() {
      binauralToggleBtn.className = `px-4 py-2 rounded-md flex-1 ${binauralEnabled ? 'bg-indigo-600 text-white' : 'bg-gray-200 hover:bg-gray-300'}`;
      binauralToggleBtn.textContent = `Binaural Beats: ${binauralEnabled ? 'ON' : 'OFF'}`;
      noiseToggleBtn.className = `px-4 py-2 rounded-md flex-1 ${noiseEnabled ? 'bg-indigo-600 text-white' : 'bg-gray-200 hover:bg-gray-300'}`;
      noiseToggleBtn.textContent = `White Noise: ${noiseEnabled ? 'ON' : 'OFF'}`;
      playButton.textContent = isPlaying ? 'Stop' : 'Start';
      playButton.className = `w-full py-3 rounded-lg font-bold text-lg mb-4 ${isPlaying ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600'} text-white`;
      const disableWhenPlaying = isPlaying;
      binauralToggleBtn.disabled = disableWhenPlaying;
      noiseToggleBtn.disabled = disableWhenPlaying;
      document.getElementById('baseFreq').disabled = disableWhenPlaying && sweepEnabled;
      document.getElementById('beatFreq').disabled = disableWhenPlaying && sweepEnabled;
      document.querySelectorAll('.preset-btn').forEach(btn => btn.disabled = disableWhenPlaying);
      exportButton.disabled = isPlaying || isExporting;
      exportButton.className = `w-full py-2 rounded font-medium ${isPlaying || isExporting ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700 text-white'}`;
      updateConfigList();
    }

    function togglePlay() { if (isPlaying) stopSound(); else startSound(); }
    function toggleAdvancedPanel() { const isVisible = advancedPanel.classList.contains('hidden'); advancedPanel.classList.toggle('hidden'); advancedToggle.textContent = isVisible ? 'Hide Advanced Options' : 'Show Advanced Options'; }

    function setBrainwavePreset(type) {
      brainwaveType = type;
      document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.classList.toggle('bg-indigo-600', btn.dataset.type === type);
        btn.classList.toggle('text-white', btn.dataset.type === type);
        btn.classList.toggle('bg-gray-200', btn.dataset.type !== type);
      });
      switch (type) {
        case 'delta': baseFreq = 200; beatFreq = 2; isochronicRate = 2; break;
        case 'theta': baseFreq = 300; beatFreq = 5; isochronicRate = 5; break;
        case 'alpha': baseFreq = 400; beatFreq = 10; isochronicRate = 10; break;
        case 'beta': baseFreq = 500; beatFreq = 18; isochronicRate = 18; break;
        case 'gamma': baseFreq = 600; beatFreq = 35; isochronicRate = 35; break;
      }
      document.getElementById('baseFreq').value = baseFreq;
      document.getElementById('baseFreqValue').textContent = baseFreq;
      document.getElementById('beatFreq').value = beatFreq;
      document.getElementById('beatFreqValue').textContent = beatFreq;
      document.getElementById('isochronicRate').value = isochronicRate;
      document.getElementById('isochronicRateValue').textContent = isochronicRate;
      updateConfigList();
    }

    function updateConfigList() {
      configListEl.innerHTML = '';
      if (binauralEnabled) {
        const leftFreq = Math.round(baseFreq);
        const rightFreq = Math.round(baseFreq + beatFreq);
        addConfigItem(`Left ear: ${leftFreq} Hz`);
        addConfigItem(`Right ear: ${rightFreq} Hz`);
        addConfigItem(`Binaural beat: ${beatFreq} Hz (${brainwaveType})`);
      }
      if (noiseEnabled) addConfigItem(`Background noise: ${noiseFreq} Hz, Q: ${noiseQ}`);
      if (isochronicEnabled) addConfigItem(`Isochronic pulses: ${isochronicRate} Hz`);
      if (sweepEnabled && binauralEnabled) addConfigItem(`Frequency sweep: ${sweepMin}-${sweepMax} Hz`);
      if (dualEnabled && binauralEnabled) addConfigItem(`Secondary binaural beat: ${secondaryBeatFreq} Hz`);
      if (monauralEnabled) addConfigItem('Monaural beats enabled');
      if (harmonicsEnabled) addConfigItem('Harmonic overtones enabled');
    }

    function addConfigItem(text) { const li = document.createElement('li'); li.textContent = text; configListEl.appendChild(li); }
    function showError(message) { errorMessageEl.textContent = message; errorMessageEl.classList.remove('hidden'); }
    function hideError() { errorMessageEl.classList.add('hidden'); }

    function createNoiseNode() {
      try {
        const ctx = audioContext;
        const bufferSize = 2 * ctx.sampleRate;
        const noiseBuffer = ctx.createBuffer(2, bufferSize, ctx.sampleRate);
        for (let channel = 0; channel < noiseBuffer.numberOfChannels; channel++) {
          const output = noiseBuffer.getChannelData(channel);
          for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
        }
        const noise = ctx.createBufferSource();
        noise.buffer = noiseBuffer;
        noise.loop = true;
        return noise;
      } catch (error) {
        showError(`Error creating noise: ${error.message}`);
        return null;
      }
    }

    function startSound() {
      hideError();
      try {
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const ctx = audioContext;
        if (ctx.state === 'suspended') ctx.resume();
        mainGain = ctx.createGain();
        mainGain.gain.value = mainVolume;
        mainGain.connect(ctx.destination);
        const merger = ctx.createChannelMerger(2);
        
        if (binauralEnabled) {
          leftOscillator = ctx.createOscillator();
          rightOscillator = ctx.createOscillator();
          leftOscillator.frequency.value = baseFreq;
          rightOscillator.frequency.value = baseFreq + beatFreq;
          const leftGain = ctx.createGain();
          const rightGain = ctx.createGain();
          leftOscillator.connect(leftGain);
          leftGain.connect(merger, 0, 0);
          rightOscillator.connect(rightGain);
          rightGain.connect(merger, 0, 1);
          leftOscillator.start();
          rightOscillator.start();
          if (harmonicsEnabled) {
            const leftHarmonic = ctx.createOscillator();
            const rightHarmonic = ctx.createOscillator();
            leftHarmonic.frequency.value = baseFreq * 2;
            rightHarmonic.frequency.value = (baseFreq + beatFreq) * 2;
            const leftHarmonicGain = ctx.createGain();
            const rightHarmonicGain = ctx.createGain();
            leftHarmonicGain.gain.value = 0.3;
            rightHarmonicGain.gain.value = 0.3;
            leftHarmonic.connect(leftHarmonicGain);
            leftHarmonicGain.connect(merger, 0, 0);
            rightHarmonic.connect(rightHarmonicGain);
            rightHarmonicGain.connect(merger, 0, 1);
            leftHarmonic.start();
            rightHarmonic.start();
          }
        }
        
        if (dualEnabled && binauralEnabled) {
          secondaryLeft = ctx.createOscillator();
          secondaryRight = ctx.createOscillator();
          secondaryLeft.frequency.value = baseFreq * 1.5;
          secondaryRight.frequency.value = baseFreq * 1.5 + secondaryBeatFreq;
          const leftGain2 = ctx.createGain();
          const rightGain2 = ctx.createGain();
          leftGain2.gain.value = 0.5;
          rightGain2.gain.value = 0.5;
          secondaryLeft.connect(leftGain2);
          leftGain2.connect(merger, 0, 0);
          secondaryRight.connect(rightGain2);
          rightGain2.connect(merger, 0, 1);
          secondaryLeft.start();
          secondaryRight.start();
        }
        
        if (monauralEnabled) {
          const monoOsc1 = ctx.createOscillator();
          const monoOsc2 = ctx.createOscillator();
          monoOsc1.frequency.value = baseFreq - beatFreq / 2;
          monoOsc2.frequency.value = baseFreq + beatFreq / 2;
          const monoGain = ctx.createGain();
          monoGain.gain.value = 0.5;
          monoOsc1.connect(monoGain);
          monoOsc2.connect(monoGain);
          monoGain.connect(merger, 0, 0);
          monoGain.connect(merger, 0, 1);
          monoOsc1.start();
          monoOsc2.start();
        }
        
        merger.connect(mainGain);
        
        if (noiseEnabled) {
          noiseNode = createNoiseNode();
          if (noiseNode) {
            noiseFilter = ctx.createBiquadFilter();
            noiseGain = ctx.createGain();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = noiseFreq;
            noiseFilter.Q.value = noiseQ;
            noiseGain.gain.value = noiseVolume;
            noiseNode.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(mainGain);
            noiseNode.start();
          }
        }
        
        isPlaying = true;
        updateUI();
        if (isochronicEnabled) startIsochronicPulses();
        if (sweepEnabled && binauralEnabled) startFrequencySweep();
      } catch (error) {
        showError(`Failed to start audio: ${error.message}`);
        stopSound();
      }
    }

    function startIsochronicPulses() {
      if (!isochronicEnabled || !isPlaying) return;
      try {
        const ctx = audioContext;
        if (!isochronicGain) {
          isochronicGain = ctx.createGain();
          isochronicGain.gain.value = 1.0;
          isochronicGain.connect(ctx.destination);
          mainGain.disconnect();
          mainGain.connect(isochronicGain);
        }
        if (isochronicInterval) clearInterval(isochronicInterval);
        let isOn = true;
        const pulseDuration = 1000 / isochronicRate;
        isochronicInterval = setInterval(() => {
          if (!isPlaying) { clearInterval(isochronicInterval); return; }
          try {
            const now = ctx.currentTime;
            if (isOn) isochronicGain.gain.linearRampToValueAtTime(0.001, now + 0.01);
            else isochronicGain.gain.linearRampToValueAtTime(1, now + 0.01);
            isOn = !isOn;
          } catch (error) { console.error("Error in isochronic pulse:", error); }
        }, pulseDuration / 2);
      } catch (error) { showError(`Failed to start isochronic pulses: ${error.message}`); }
    }

    function startFrequencySweep() {
      if (!sweepEnabled || !isPlaying || !binauralEnabled) return;
      try {
        if (sweepInterval) clearInterval(sweepInterval);
        const ctx = audioContext;
        const stepSize = 0.05;
        let currentBeatFreq = sweepMin;
        let direction = 1;
        sweepInterval = setInterval(() => {
          if (!isPlaying || !sweepEnabled) { clearInterval(sweepInterval); return; }
          currentBeatFreq += stepSize * direction;
          if (currentBeatFreq >= sweepMax) { direction = -1; currentBeatFreq = sweepMax; }
          else if (currentBeatFreq <= sweepMin) { direction = 1; currentBeatFreq = sweepMin; }
          if (rightOscillator) {
            rightOscillator.frequency.setValueAtTime(baseFreq + currentBeatFreq, ctx.currentTime);
            document.getElementById('beatFreqValue').textContent = currentBeatFreq.toFixed(2);
            document.getElementById('beatFreq').value = currentBeatFreq;
          }
        }, 100);
      } catch (error) { showError(`Failed to start frequency sweep: ${error.message}`); }
    }

    function stopIsochronicPulses() {
      if (isochronicInterval) { clearInterval(isochronicInterval); isochronicInterval = null; }
      if (isochronicGain && mainGain && audioContext) {
        try {
          isochronicGain.gain.value = 1.0;
          mainGain.disconnect();
          mainGain.connect(audioContext.destination);
          isochronicGain = null;
        } catch (error) { console.error("Error stopping isochronic pulses:", error); }
      }
    }

    function stopSound() {
      try {
        if (sweepInterval) { clearInterval(sweepInterval); sweepInterval = null; }
        if (isochronicInterval) { clearInterval(isochronicInterval); isochronicInterval = null; }
        if (isochronicGain) { isochronicGain.gain.value = 1.0; isochronicGain = null; }
        const stopAudioNode = (node) => { if (node) { try { node.stop(); node.disconnect(); } catch (e) { console.error(`Error stopping node:`, e); } } };
        stopAudioNode(leftOscillator); stopAudioNode(rightOscillator); stopAudioNode(secondaryLeft); stopAudioNode(secondaryRight); stopAudioNode(noiseNode);
        leftOscillator = null; rightOscillator = null; secondaryLeft = null; secondaryRight = null; noiseNode = null;
        const disconnectNode = (node) => { if (node) { try { node.disconnect(); } catch (e) { console.error(`Error disconnecting node:`, e); } } };
        disconnectNode(mainGain); disconnectNode(noiseGain); disconnectNode(noiseFilter);
        mainGain = null; noiseGain = null; noiseFilter = null;
        if (audioContext && audioContext.state !== 'closed') audioContext.close().then(() => audioContext = null).catch(e => console.error("Error closing audio context:", e));
      } catch (error) { console.error("Error stopping sound:", error); } finally { isPlaying = false; updateUI(); }
    }

    function handleExport() {
      if (isExporting || isPlaying) return;
      try {
        setExporting(true);
        updateExportProgress(0);
        hideError();
        const durationInSeconds = exportDuration * 60;
        renderAudioToBuffer(durationInSeconds)
          .then(audioBuffer => convertBufferToMp3(audioBuffer))
          .then(mp3Blob => {
            const url = URL.createObjectURL(mp3Blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${exportFilename || 'brainwave-session'}.mp3`;
            a.click();
            URL.revokeObjectURL(url);
            updateExportProgress(100);
            document.getElementById('progressText').textContent = "Download complete!";
            setTimeout(() => setExporting(false), 2000);
          })
          .catch(error => { console.error("Export failed:", error); showError(`Export failed: ${error.message}`); setExporting(false); });
      } catch (error) { console.error("Export failed:", error); showError(`Export failed: ${error.message}`); setExporting(false); }
    }

    function setExporting(state) {
      isExporting = state;
      exportButton.disabled = state || isPlaying;
      exportButton.className = `w-full py-2 rounded font-medium ${state || isPlaying ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700 text-white'}`;
      if (state) exportProgressEl.classList.remove('hidden');
      else setTimeout(() => exportProgressEl.classList.add('hidden'), 2000);
    }

    function updateExportProgress(progress) { progressBarEl.style.width = `${progress}%`; progressTextEl.textContent = progress < 100 ? `Generating MP3... ${progress}%` : "Download complete!"; }

    async function renderAudioToBuffer(durationInSeconds) {
      try {
        const offlineContext = new OfflineAudioContext(2, 44100 * durationInSeconds, 44100);
        const offlineMainGain = offlineContext.createGain();
        offlineMainGain.gain.value = mainVolume;
        offlineMainGain.connect(offlineContext.destination);
        const merger = offlineContext.createChannelMerger(2);
        merger.connect(offlineMainGain);
        
        if (binauralEnabled) {
          const leftOsc = offlineContext.createOscillator();
          const rightOsc = offlineContext.createOscillator();
          leftOsc.frequency.value = baseFreq;
          rightOsc.frequency.value = baseFreq + beatFreq;
          const leftGain = offlineContext.createGain();
          const rightGain = offlineContext.createGain();
          leftOsc.connect(leftGain);
          leftGain.connect(merger, 0, 0);
          rightOsc.connect(rightGain);
          rightGain.connect(merger, 0, 1);
          leftOsc.start();
          rightOsc.start();
          if (sweepEnabled) {
            const totalSteps = durationInSeconds * 10;
            const stepSize = (sweepMax - sweepMin) / (totalSteps / 2);
            let currentBeatFreq = sweepMin;
            let direction = 1;
            for (let i = 0; i < totalSteps; i++) {
              const timeAtStep = i / 10;
              currentBeatFreq += stepSize * direction;
              if (currentBeatFreq >= sweepMax) { direction = -1; currentBeatFreq = sweepMax; }
              else if (currentBeatFreq <= sweepMin) { direction = 1; currentBeatFreq = sweepMin; }
              rightOsc.frequency.setValueAtTime(baseFreq + currentBeatFreq, timeAtStep);
            }
          }
          if (harmonicsEnabled) {
            const leftHarmonic = offlineContext.createOscillator();
            const rightHarmonic = offlineContext.createOscillator();
            leftHarmonic.frequency.value = baseFreq * 2;
            rightHarmonic.frequency.value = (baseFreq + beatFreq) * 2;
            const leftHarmonicGain = offlineContext.createGain();
            const rightHarmonicGain = offlineContext.createGain();
            leftHarmonicGain.gain.value = 0.3;
            rightHarmonicGain.gain.value = 0.3;
            leftHarmonic.connect(leftHarmonicGain);
            leftHarmonicGain.connect(merger, 0, 0);
            rightHarmonic.connect(rightHarmonicGain);
            rightHarmonicGain.connect(merger, 0, 1);
            leftHarmonic.start();
            rightHarmonic.start();
          }
          if (dualEnabled) {
            const secondaryLeft = offlineContext.createOscillator();
            const secondaryRight = offlineContext.createOscillator();
            secondaryLeft.frequency.value = baseFreq * 1.5;
            secondaryRight.frequency.value = baseFreq * 1.5 + secondaryBeatFreq;
            const leftGain2 = offlineContext.createGain();
            const rightGain2 = offlineContext.createGain();
            leftGain2.gain.value = 0.5;
            rightGain2.gain.value = 0.5;
            secondaryLeft.connect(leftGain2);
            leftGain2.connect(merger, 0, 0);
            secondaryRight.connect(rightGain2);
            rightGain2.connect(merger, 0, 1);
            secondaryLeft.start();
            secondaryRight.start();
          }
          if (monauralEnabled) {
            const monoOsc1 = offlineContext.createOscillator();
            const monoOsc2 = offlineContext.createOscillator();
            monoOsc1.frequency.value = baseFreq - beatFreq / 2;
            monoOsc2.frequency.value = baseFreq + beatFreq / 2;
            const monoGain = offlineContext.createGain();
            monoGain.gain.value = 0.5;
            monoOsc1.connect(monoGain);
            monoOsc2.connect(monoGain);
            monoGain.connect(merger, 0, 0);
            monoGain.connect(merger, 0, 1);
            monoOsc1.start();
            monoOsc2.start();
          }
        }
        
        if (noiseEnabled) {
          const bufferSize = 2 * offlineContext.sampleRate;
          const noiseBuffer = offlineContext.createBuffer(2, bufferSize, offlineContext.sampleRate);
          for (let channel = 0; channel < noiseBuffer.numberOfChannels; channel++) {
            const output = noiseBuffer.getChannelData(channel);
            for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
          }
          const noiseNode = offlineContext.createBufferSource();
          noiseNode.buffer = noiseBuffer;
          noiseNode.loop = true;
          const noiseFilter = offlineContext.createBiquadFilter();
          const noiseGain = offlineContext.createGain();
          noiseFilter.type = 'bandpass';
          noiseFilter.frequency.value = noiseFreq;
          noiseFilter.Q.value = noiseQ;
          noiseGain.gain.value = noiseVolume;
          noiseNode.connect(noiseFilter);
          noiseFilter.connect(noiseGain);
          noiseGain.connect(offlineMainGain);
          if (noiseSweepEnabled) {
            const totalSteps = durationInSeconds * 10;
            const stepSize = (noiseMaxFreq - noiseMinFreq) / (totalSteps / 2);
            let currentNoiseFreq = noiseMinFreq;
            let direction = 1;
            for (let i = 0; i < totalSteps; i++) {
              const timeAtStep = i / 10;
              currentNoiseFreq += stepSize * direction;
              if (currentNoiseFreq >= noiseMaxFreq) { direction = -1; currentNoiseFreq = noiseMaxFreq; }
              else if (currentNoiseFreq <= noiseMinFreq) { direction = 1; currentNoiseFreq = noiseMinFreq; }
              noiseFilter.frequency.setValueAtTime(currentNoiseFreq, timeAtStep);
            }
          }
          noiseNode.start();
        }
        
        if (isochronicEnabled) {
          const isochronicGain = offlineContext.createGain();
          isochronicGain.gain.value = 1.0;
          offlineMainGain.disconnect();
          offlineMainGain.connect(isochronicGain);
          isochronicGain.connect(offlineContext.destination);
          const pulseDuration = 1000 / isochronicRate;
          const pulseInterval = pulseDuration / 2;
          const pulseCount = Math.ceil((durationInSeconds * 1000) / pulseInterval);
          let isOn = true;
          for (let i = 0; i < pulseCount; i++) {
            const timeInSeconds = (i * pulseInterval) / 1000;
            if (isOn) { isochronicGain.gain.setValueAtTime(1, timeInSeconds); isochronicGain.gain.linearRampToValueAtTime(0.001, timeInSeconds + 0.01); }
            else { isochronicGain.gain.setValueAtTime(0.001, timeInSeconds); isochronicGain.gain.linearRampToValueAtTime(1, timeInSeconds + 0.01); }
            isOn = !isOn;
          }
        }
        
        const totalSuspendPoints = 20;
        const suspendInterval = durationInSeconds / totalSuspendPoints;
        for (let i = 1; i <= totalSuspendPoints; i++) {
          const suspendTime = i * suspendInterval;
          offlineContext.suspend(suspendTime).then(() => { updateExportProgress(Math.round((i / totalSuspendPoints) * 80)); offlineContext.resume(); });
        }
        
        return offlineContext.startRendering();
      } catch (error) { throw new Error(`Error rendering audio: ${error.message}`); }
    }

    async function convertBufferToMp3(audioBuffer, bitRate = 128) {
      try {
        updateExportProgress(90);
        if (typeof lamejs === 'undefined') throw new Error('MP3 encoder library (lamejs) not found');
        const channels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const samples = audioBuffer.length;
        const leftChannel = audioBuffer.getChannelData(0);
        const rightChannel = channels > 1 ? audioBuffer.getChannelData(1) : leftChannel;
        const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, bitRate);
        const chunkSize = 1152;
        const totalChunks = Math.ceil(samples / chunkSize);
        const mp3Data = [];
        for (let i = 0; i < totalChunks; i++) {
          if (i % 100 === 0) updateExportProgress(Math.round(90 + (i / totalChunks) * 10));
          const start = i * chunkSize;
          const end = Math.min(start + chunkSize, samples);
          const length = end - start;
          const leftChunk = new Int16Array(length);
          const rightChunk = new Int16Array(length);
          for (let j = 0; j < length; j++) {
            leftChunk[j] = Math.max(-32768, Math.min(32767, Math.floor(leftChannel[start + j] * 32768)));
            rightChunk[j] = Math.max(-32768, Math.min(32767, Math.floor(rightChannel[start + j] * 32768)));
          }
          const mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
          if (mp3buf.length > 0) mp3Data.push(mp3buf);
        }
        const finalizeBuf = mp3encoder.flush();
        if (finalizeBuf.length > 0) mp3Data.push(finalizeBuf);
        return new Blob(mp3Data, { type: 'audio/mp3' });
      } catch (error) { throw new Error(`Error encoding MP3: ${error.message}`); }
    }

    init();
  </script>
</body>
</html>
